#include <types.h>
#include <lib.h>
#include <synch.h>
#include <test.h>
#include <thread.h>
#include <queue.h>
#include "paintshop.h"



/*
 * **********************************************************************
 * YOU ARE FREE TO CHANGE THIS FILE BELOW THIS POINT AS YOU SEE FIT
 *
 */



/*
 * **********************************************************************
 * FUNCTIONS EXECUTED BY CUSTOMER THREADS
 * **********************************************************************
 */

/*
 * order_paint()
 *
 * Takes one argument specifying the can to be filled. The function
 * makes the can available to staff threads and then blocks until the staff
 * have filled the can with the appropriately tinted paint.
 *
 * The can itself contains an array of requested tints.
 */ 

void order_paint(struct paintcan *can)
{
    
  struct orderCan *order = kmalloc(sizeof(struct orderCan));
  if(order == NULL)
    panic("memory allocation failed for orderCan\n");
  
  order->orderSem = sem_create("order", 0); //create semaphore for blocking this customer till order is done
  if (order->orderSem == NULL) {
    panic("runpaintshop: out of memory\n");
  }
  order->can = can;         //give it the can
  
  q_addtail(buffer,order);  //place the order into the buffer

  V(QSem);                  //increment number of orders in buffer, possibly wake sleeping staff
  P(order->orderSem);       //sleep until order is serviced

  sem_destroy(order->orderSem);
  kfree(order);             //destroy
}



/*
 * go_home()
 *
 * This function is called by customers when they go home. It could be
 * used to keep track of the number of remaining customers to allow
 * paint shop staff threads to exit when no customers remain.
 */

void go_home()
{
    no_of_customers--;      //keep track of total number of customers
    if(no_of_customers==0)
    	V(QSem);			//wake the poor staff and let them know they're done for the day
}


/*
 * **********************************************************************
 * FUNCTIONS EXECUTED BY PAINT SHOP STAFF THREADS
 * **********************************************************************
 */

/*
 * take_order()
 *
 * This function waits for a new order to be submitted by
 * customers. When submitted, it records the details, and returns a
 * pointer to something representing the order.
 *
 * The return pointer type is void * to allow freedom of representation
 * of orders.
 *
 * The function can return NULL to signal the staff thread it can now
 * exit as their are no customers nor orders left. 
 */
 
void * take_order(void)
{
    if(no_of_customers==0)	//customers already left
        return NULL;

    struct orderCan *order;

    P(QSem);
    if(no_of_customers==0) {
    	V(QSem);			//wake-up all the remaining staff because no more orders to serve
    	return NULL;
    }
    
    P(bufferBlocker);
    order = (struct orderCan*) q_remhead(buffer);
    V(bufferBlocker);

    return order;
}


/*
 * fill_order()
 *
 * This function takes an order generated by take order and fills the
 * order using the mix() function to tint the paint.
 *
 * NOTE: IT NEEDS TO ENSURE THAT MIX HAS EXCLUSIVE ACCESS TO THE TINTS
 * IT NEEDS TO USE TO FILE THE ORDER.
 */

void fill_order(void *v)
{
  	struct orderCan *order = (struct orderCan*) v;
  	int i,col;
  
  	for(i = 0; i < PAINT_COMPLEXITY; i++) {
   		col = order->can->requested_colours[i] - 1;
      	if(col > 0)
        	P(tintSem[col]);   //block on the tints required
  }
  
  mix(order->can);
  
  for(i = 0; i < PAINT_COMPLEXITY; i++) {
      col = order->can->requested_colours[i] - 1;
      if(col > 0)
         V(tintSem[col]);   //release locks on tints
  }
}


/*
 * serve_order()
 *
 * Takes a filled order and makes it available to the waiting customer.
 */

void serve_order(void *v)
{
  struct orderCan *order = (struct orderCan*) v;
  V(order->orderSem);
}



/*
 * **********************************************************************
 * INITIALISATION AND CLEANUP FUNCTIONS
 * **********************************************************************
 */


/*
 * paintshop_open()
 *
 * Perform any initialisation you need prior to opening the paint shop to
 * staff and customers
 */

void paintshop_open(void)
{
	no_of_customers = NCUSTOMERS;  //globally defined
    int i;
    for(i = 0 ; i < NCOLOURS ; i++){
        tintSem[i] = sem_create("tint sem", 1);     //making sure multiple staff don't touch the same tint simultaneously
        if(tintSem[i] == NULL){
            panic("paintshop_open: out of memory\n");
        }
    }
    
    QSem = sem_create("Queue Sem", 0);      //making sure something is in queue for taking
    if(QSem == NULL){
        panic("paintshop_open: out of memory\n");
    }
    
    bufferBlocker = sem_create("Buffer Sem", 1);      //implemented queue of OS161 does not have atomic instructions
    if(bufferBlocker == NULL){
        panic("paintshop_open: out of memory\n");
    }
    
    //initializing buffer
    buffer = q_create(NCUSTOMERS);
    if(buffer == NULL)
        panic("Couldn't create Queue\n");
}

/*
 * paintshop_close()
 *
 * Perform any cleanup after the paint shop has closed and everybody
 * has gone home.
 */

void paintshop_close(void)
{
    sem_destroy(QSem);
    int i;
    for(i = 0; i < NCOLOURS; i++)
        sem_destroy(tintSem[i]);
    q_destroy(buffer);
}
